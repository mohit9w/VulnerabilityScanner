package org.vs.application.services;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.commons.lang3.RegExUtils;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.vs.application.CVEFinder;
import org.vs.application.config.VSApplicationConfig;
import org.vs.application.model.CVEDetail;
import org.vs.application.model.CVEDetailConstant;
import org.vs.application.model.CVEResult;
import org.vs.cvedetails.handler.ProductApi;
import org.vs.cvedetails.handler.VulnApi;
import org.vs.cvedetails.invoker.ApiException;
import org.vs.cvedetails.model.UserVulnListByCpe200Response;
import org.vs.cvedetails.vs.handler.VsProductApi;
import org.vs.cvedetails.vs.handler.VsVulnApi;

import java.time.LocalDate;
import java.util.List;
import java.util.Map;

@Component
public class VsCVEFinder implements CVEFinder {

    private final VulnApi vulnApi = new VsVulnApi();
    private final ProductApi productApi = new VsProductApi();
    @Autowired
    private VSApplicationConfig config;

    /**
     * @return
     */
    @Override
    public CVEResult getCVEDetails(String name, String vendor, String version) {
        vulnApi.getApiClient().setBearerToken(config.getCvedetailsBearerToken());
        Integer exploitExists = null;
        Integer isInCISAKEV = null;
        LocalDate publishDateStart = null;
        LocalDate publishDateEnd = null;
        LocalDate updateDateStart = null;
        LocalDate updateDateEnd = null;
        LocalDate cisaExploitAddDateStart = null;
        LocalDate cisaExploitAddDateEnd = null;
        LocalDate cisaActionDueDateStart = null;
        LocalDate cisaActionDueDateEnd = null;
        Integer maxCvssBaseMin = null;
        Integer maxCvssBaseMax = null;
        Integer epssPercentMin = null;
        Integer epssPercentMax = null;
        Integer isOverflow = null;
        Integer isMemoryCorruption = null;
        Integer isSqlInjection = null;
        Integer isXss = null;
        Integer isDirectoryTraversal = null;
        Integer isFileInclusion = null;
        Integer isCsrf = null;
        Integer isXxe = null;
        Integer isSsrf = null;
        Integer isOpenRedirect = null;
        Integer isInputValidation = null;
        Integer isCodeExecution = null;
        Integer isBypass = null;
        Integer isGainPrivilege = null;
        Integer isDenialOfService = null;
        Integer isInformationLeak = null;
        String outputFormat = null;
        Integer pageNumber = null;
        Integer resultsPerPage = null;
        try {
            UserVulnListByCpe200Response response = vulnApi.userVulnListByVpv(vendor, ProductTypes.APPLICATION.value, name, version,
                    exploitExists, isInCISAKEV, publishDateStart, publishDateEnd, updateDateStart, updateDateEnd, cisaExploitAddDateStart,
                    cisaExploitAddDateEnd, cisaActionDueDateStart, cisaActionDueDateEnd, maxCvssBaseMin, maxCvssBaseMax, epssPercentMin,
                    epssPercentMax, isOverflow, isMemoryCorruption, isSqlInjection, isXss, isDirectoryTraversal, isFileInclusion, isCsrf,
                    isXxe, isSsrf, isOpenRedirect, isInputValidation, isCodeExecution, isBypass, isGainPrivilege, isDenialOfService,
                    isInformationLeak, outputFormat, pageNumber, resultsPerPage);
            return parseSuccessResponse(response, name, vendor, version);
        } catch (ApiException e) {
            return parseErrorResponse(e, name, vendor, version);
        }
    }

    @Override
    public CVEResult parseSuccessResponse(UserVulnListByCpe200Response response, String name, String vendor, String version) {
        CVEResult result = new CVEResult();
        if (response.getResults() != null && !response.getResults().isEmpty()) {
            List<Object> responseResult = response.getResults();
            result.setName(name);
            result.setVersion(version);
            result.setVendor(vendor);
            for (Object obj : responseResult) {
                Map<String, String> resultMap = (Map) obj;
                CVEDetail detail = new CVEDetail();
                detail.setCveId(resultMap.getOrDefault(CVEDetailConstant.CVE_ID, CVEDetailConstant.EMPTY_STRING));
                detail.setCveLink(config.getNvdUrl() + detail.getCveId());
                detail.setSummary(RegExUtils.replaceAll(resultMap.getOrDefault(CVEDetailConstant.SUMMARY, CVEDetailConstant.EMPTY_STRING), "\\. ", "\\.<br>"));
                result.setVendor(resultMap.getOrDefault(CVEDetailConstant.VENDOR_NAME, vendor));
                result.getCveDetailsList().add(detail);
            }
        }
        return result;
    }


    @Override
    public CVEResult parseErrorResponse(ApiException e, String name, String vendor, String version) {
        CVEDetail detail = new CVEDetail();
        detail.setError(true);
        ObjectMapper mapper = new ObjectMapper();
        try {
            JsonNode data = mapper.readTree(e.getResponseBody());
            detail.setErrorMessage(String.valueOf(data.get("errors").get("error")));
        } catch (JsonProcessingException jsonProcessingException) {
            throw new RuntimeException(jsonProcessingException);
        }
        CVEResult result = new CVEResult(name, version, vendor);
        result.getCveDetailsList().add(detail);

        return result;

    }

    @Override
    public List<String> findAllCsvCve() {
        /*try {
            VSExecutor vsExecutor = findInstalledSoftware();
            if(vsExecutor != null){
                StringBuilder builder = new StringBuilder(vsExecutor.getOutputStream().toString());
                File tempFile;
                if (isWriteEnabled()){
                    tempFile = new File(VSUtils.FILE_PATH + VSUtils.INSTALLED_SOFTWARE_FILE_NAME_CSV);
                }else{
                    tempFile = File.createTempFile("temp", "csv");
                }
                FileUtils.writeStringToFile(tempFile, builder.toString().trim(), StandardCharsets.UTF_8.name());
                CSVParser csvParser = new CSVParser();
                List<CVEResult> results = csvParser.csvToCVEParser(tempFile);
                tempFile.deleteOnExit();
                vsExecutor.clearAll();
            } else{
                return Collections.emptyList();
            }
        } catch (IOException | InterruptedException e) {
            throw new RuntimeException(e);
        }*/
        return null;
    }

    @Override
    public CVEResult findListedCVE(String name, String version, String vendor) {
        CVEResult result = findCorrectVendor(name, version, vendor);
        if (!StringUtils.isEmpty(result.getVendor())) {
            return getCVEDetails(result.getName(), result.getVendor(), result.getVersion());
        }

        return getCVEDetails(name, vendor, version);
    }

    @Override
    public CVEResult findCorrectVendor(String name, String version, String vendor) {
        productApi.getApiClient().setBearerToken(config.getCvedetailsBearerToken());
        try {
            UserVulnListByCpe200Response response = productApi.userProductVpvSearch(RegExUtils.removeAll(vendor, "[^a-zA-Z0-9 ]+")
                    + " " + version, "vpv");
            return parseSuccessResponse(response, name, vendor, version);
        } catch (ApiException e) {
            return parseErrorResponse(e, name, vendor, version);
        }
    }
}
