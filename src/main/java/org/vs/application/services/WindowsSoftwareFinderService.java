package org.vs.application.services;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.commons.exec.*;
import org.apache.commons.lang3.RegExUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.springframework.stereotype.Component;
import org.vs.application.model.CVEResult;
import org.vs.application.services.interfaces.SoftwareFinderService;
import org.vs.generated.Package;
import org.vs.generated.PackagesSchema20;
import org.vs.generated.Source;
import org.vs.utils.VSUtils;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;

import static org.vs.utils.VSUtils.INSTALLED_SOFTWARE_FILE_NAME_JSON;

@Component
public class WindowsSoftwareFinderService implements SoftwareFinderService {
    private static final ObjectMapper mapper = new ObjectMapper();

    public WindowsSoftwareFinderService() {
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    }

    @Override
    public boolean isWriteEnabled() {
        return SystemUtils.getUserHome().canWrite();
    }

    /**
     * @return
     */
    @Override
    public List<CVEResult> findInstalledSoftware() throws IOException, InterruptedException {

        List<CVEResult> softwares = new ArrayList<>();
        if (isWriteEnabled()) {
            CommandLine cmdLine = new CommandLine(USE_PROGRAM_CMD);
            String[] cmdArr = StringUtils.split(WIN_PS_COMMAND_WITH_FILE, " ");
            setCMDLineArguments(cmdArr, cmdLine);
            ExecuteWatchdog watchdog = ExecuteWatchdog.builder().setTimeout(Duration.ofSeconds(120)).get();
            DefaultExecutor executor = DefaultExecutor.builder().get();
            try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
                executor.setWatchdog(watchdog);
                executor.setStreamHandler(new PumpStreamHandler(outputStream));
                DefaultExecuteResultHandler resultHandler = new DefaultExecuteResultHandler();
                executor.execute(cmdLine, resultHandler);
                resultHandler.waitFor();
                if (0 == resultHandler.getExitValue() && resultHandler.hasResult()) {
                    parseJsonResults(softwares);
                }
            }
        }
        System.out.println("Returning found software's");
        return softwares;
    }

    @Override
    public void parseJsonResults(List<CVEResult> results) throws IOException {

        File tempFile = new File(VSUtils.FILE_PATH + INSTALLED_SOFTWARE_FILE_NAME_JSON);
        PackagesSchema20 packageList = mapper.readValue(tempFile, PackagesSchema20.class);
        List<Source> sources = packageList.getSources();
        if (!sources.isEmpty()) {
            for (Source source : sources) {
                List<Package> packages = source.getPackages();
                if (!packages.isEmpty()) {
                    for (Package pkg : packages) {
                        String[] identifiers = pkg.getPackageIdentifier().split("\\.");
                        String version = RegExUtils.removeAll(pkg.getVersion(), "<|>").trim();
                        //result = new CVEResult(identifiers[1], version, RegExUtils.removeAll(identifiers[0],"([^\\w]+)"));
                        CVEResult result = new CVEResult(identifiers[1], version, identifiers[0]);
                        results.add(result);
                    }
                }
            }
        }
    }

    private void setCMDLineArguments(String[] cmdArr, CommandLine cmdLine) {
        for (String cmd : cmdArr) {
            cmdLine.addArgument(cmd);
        }
    }
}
